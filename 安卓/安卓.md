# 安卓简介

## 系统架构

`Android`大致可以分为4层架构：Linux内核层、系统运行库层、应用框架层和应用层。

**Linux内核层**

这一层为`Android`设备的各种硬件提供了底层驱动。

**系统运行库层**

通过一些`C/C++`库为`Android`系统提供了主要的特性支持。

这一层还有`Android`运行时库，主要提供了核心库，允许开发者使用`Java`语言来编写`Android`应用。

运行时库还包括`Dalvik`虚拟机，（5.0后改为`ART`运行环境），是否每一个`Android`应用都能运行在独立的进程中，并且拥有一个自己的虚拟机实例。

**应用框架层**

提供了构建应用程序时可能用到的各种`API`。

**应用层**

所有安装在手机上的应用程序都属于这一层。

## 四大组件

`Android`系统四大组件分别是`Activity`、`Serice`、`BroadcastReceiver`和`ContentProvider`。

**Activity**

是所有`Android`应用程序的门面。

**Service**

后台运行的服务，即使退出了应用。

**BroadcastReceiver**

允许应用接受来自各个地方的广播消息、向外发出广播消息。

**ContentProvider**

应用程序直接共享数据。

## 文件目录介绍

**注册Activity**

所有使用到的`Activity`都需要在`AndroidManifest.xml`中注册。

**res目录下的结构资源**

- `drawable`用来放图片
- `mipmap`用来放图标
- `values`用来放字符串、样式、颜色等配置
- `layout`用来放布局

**build.gradle文件**

`Android`中有两个`build.gradle`文件，一个在项目根目录中，一个在`app`目录中。

- 根目录中的文件：全局的项目构建配置
  - `repositories`声明代码仓库
  - `dependencies`声明插件
- `app`目录中的文件：
  - `plugins`声明插件
  - `android`配置项目构建的各种属性，包括编译版本、构建工具版本版本信息等
    - `buildTypes`用于指定生成安装文件的相关配置，包括代码混淆
  - `dependencies`指定当前项目所有的依赖关系：本地依赖`implementation fileTre`、库依赖`implementation project`、远程依赖`implementation`

## 日志

`Log(android.util.Log)`

- `Log.v()`打印最繁琐、意义小的日志。级别为`verbose`
- `Log.d()`打印调试信息，级别为`debug`
- `Log.i()`打印比较重要的数据。可以帮助分析用户行为的数据。级别为`info`
- `Log.w()`打印警告信息。级别为`warn`
- `Log.e()`打印错误信息。级别为`error`

# Kotlin

## 变量

在`Kotlin`中声明变量只允许使用关键字`val`和`var`。

- `val (value)`用于声明不可变的变量，相当于`Java`中的`final`变量。
- `var (variable)`用于声明可变的变量，相当于`Java`中的非`final`变量。

**类型**

`Kotlin`拥有类型推导机制，声明且赋值后，自动推导成对应类型，且不允许再赋值成其他类型。

但是对一个变量延迟赋值的话，`Kotlin`无法自动推导他的类型。这时候就需要显示声明变量类型。

```kotlin
val a: Int = 10
```

在`Kotnlin`中，`Int`为首字母大写，`Kotlin`完全抛弃了`Java`的基础类型，全部使用对象数据类型。

| Java基本数据类型 | Kotlin对象数据类型 | 数据类型说明 |
| :--------------: | :----------------: | :----------: |
|      `int`       |       `Int`        |     整型     |
|      `long`      |       `Long`       |    长整型    |
|     `short`      |      `Short`       |    短整型    |
|     `float`      |      `Float`       | 单精度浮点型 |
|     `double`     |      `Double`      | 双精度浮点型 |
|    `boolean`     |     `Boolean`      |    布尔型    |
|      `char`      |       `Char`       |    字符型    |
|      `byte`      |       `Byte`       |    字节型    |

## 函数

```kotlin
fun largeNumber(param1 : Int, param2 : Int) : Int {
    return max(param1, param2)
}
```

当一个函数中只有一行代码时，`Kotlin`允许我们不必编写函数体，可以直接将唯一的一行代码写在函数定义的尾部，中间用等号连接即可。加上`Kotlin`的类型推导机制，以上代码可以简化为

```kotlin
fun largeNumber(param1 : Int, param2 : Int) = max(param1, param2)
```

## 逻辑控制

### if 条件语句

`Kotlin`中的`if`语句相比于`Java`有一个额外的功能，它是可以有返回值的，返回值就是`if`语句每一个条件中最后一行代码的返回值

```kotlin
fun largerNumber(num1: Int, num2: Int): Int {
    val value = if (num1 > num2) {
        num1
    } else {
        num2
    }
    return value
}
```

语法糖优化精简

```kotlin
fun largerNumber(num1: Int, num2: Int) = if (num1 > num2) {
    num1
} else {
    num2
}
//fun largerNumber(num1: Int, num2: Int) = if (num1 > num2) num1 else num2
```

### when 条件语句

**精确匹配**

```kotlin
fun getScore(name: String) = when (name) {
    "Tom" -> 86
    "Jim" -> 77
    "Jack" -> 95
    "Lily" -> 100
    else -> 0
}
```

**类型匹配**

```kotlin
fun checkNumber(num: Number) {
    when (num) {
        is Int -> println("number is Int")
        is Double -> println("number is Double")
        else -> println("number not support")
    }
}
//is关键字就是类型匹配的核心，它相当于Java中的instanceof关键字
```

`when`语句的结构体：

`匹配值 -> { 执行逻辑 }`

当执行逻辑只有一行代码是，可以省略`{}`

`when`可以不带参数

```kotlin
fun getScore(name: String) = when {
    name.startsWith("Tom") -> 86
    name == "Jim" -> 77
    name == "Jack" -> 95
    name == "Lily" -> 100
    else -> 0
}
```

### 循环语句

`Kotlin`中的区间概念

```kotlin
val range = 0..10
```

上述代码表示创建了一个0到10的区间，并且两端都是闭区间，用数学的方式表达出来就是[0, 10]

其中，`..`是创建两端闭区间的关键字，在`..`的两边指定区间的左右端点就可以创建一个区间了。

```kotlin
fun main() {
    for (i in 0..10) {
        println(i)
    }
}
```

`Kotlin`中可以使用`until`关键字来创建一个左闭右开的区间

```kotlin
val range = 0 until 10
```

上述代码表示创建了一个0到10的左闭右开区间，它的数学表达方式是[0, 10)

`step`关键字用于跳过其中的一些元素

```kotlin
fun main() {
    for (i in 0 until 10 step 2) {
        println(i)
    }
}
```

`..`和`until`关键字都要求区间的左端必须小于等于区间的右端，也就是这两种关键字创建的都是一个**升序的区间**

**降序的区间**，可以使用`downTo`关键字

```kotlin
fun main() {
    for (i in 10 downTo 1) {
        println(i)
    }
}
```

